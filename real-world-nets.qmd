# Real-world networks

```{r}
#| warning: false
library(ggraph)
library(osmdata)
library(sf)
library(sfnetworks)
library(tidygraph)
library(tidyverse)
```

## Getting data from OpenStreetMap

A common source for open geospatial network data is OpenStreetMap (<https://www.openstreetmap.org>), a crowd-sourced map platform. As an example, we will retrieve the street network of Stellenbosch in South Africa.
We do so using the `osmdata` package, which is the R interface to the Overpass API of OpenStreetMap.

:::{.callout-tip}
For larger networks, it is not recommended to use the Overpass API for data retrieval. You can better download an OpenStreetMap extract (for example from [Geofabrik](http://download.geofabrik.de/)) and read it into R using the `osmextract` package.
:::

The code below shows you how to obtain the data from OSM. 
However, to avoid exhausting the API, we have saved the data in this repository and will read it below. 

```{r}
#| eval: false
## Bounding box
bounds = "Cape Town Ward 115, South Africa"
# Obtain Cape Town from OSM
bb = getbb(bounds, format_out = 'sf_polygon')

## Roads
# Download OSM data for Cape Town, with the key=highway
roads = opq(bounds) |>
  add_osm_feature(key = "highway") |>
  osmdata_sf() |> 
  osm_poly2line()
```

```{r}
#| eval: false
# Create a LINESTRING sf object with selected columns
lines = roads |> 
  pluck("osm_lines") |> 
  st_intersection(bb) |> 
  filter(st_is(geometry, c("LINESTRING", "MULTILINESTRING"))) |> 
  st_cast("LINESTRING") |> 
  dplyr::select(
    name, 'type' = highway, 
    maxspeed, surface, 
    lanes, oneway, cycleway
  )|> 
  filter(!type %in% c("bus_stop", "elevator", "steps", "busway",
                      "corridor", "track", "living_street", NA))
```

Here, we read the .gpkg file.

```{r}
lines = read_sf("data/south-africa/cape-town/cape_town_osm_roads.gpkg") |> rename(geometry = geom)
```

```{r}
#| eval: false
mapview(lines, map.types = "OpenStreetMap")
```

## Creating the network

The retrieved streets from OpenStreetMap can be converted into a sfnetwork object, and project it to the South African CRS.

```{r}
net = as_sfnetwork(lines, directed = FALSE) |>
  st_transform(22293)

net
```

## Cleaning the network

We perform the cleaning operations that we showed previously on the dirty toy network.

```{r}
net_clean = net |>
  convert(to_spatial_subdivision) |>
  convert(to_spatial_smooth, .clean = TRUE)
```

```{r}
#| layout-ncol: 2
#| fig-height: 6
#| fig-cap: 
#|   - "Original OSM network"
#|   - "Clean network"
ggraph(net, layout = "sf") +
  geom_edge_sf() +
  geom_node_sf(size = 0.5)
ggraph(net_clean, layout = "sf") +
  geom_edge_sf() +
  geom_node_sf(size = 0.5)
```

```{r}
with_graph(net, graph_component_count())
with_graph(net_clean, graph_component_count())
```

```{r}
net_clean = net_clean |>
  convert(to_largest_component, type = "strong")
```

## Analyzing the network

First we can compute some simple summary statistics, as we have shown before.

For example, the average node degree ...

```{r}
net_clean |>
  activate(nodes) |>
  mutate(degree = centrality_degree()) |>
  pull(degree) |>
  mean()
```

Now lets create some random points in the proximity of the network edges.

```{r}
points = net_clean |>
  activate(nodes) |>
  st_geometry() |>
  st_combine() |>
  st_concave_hull(ratio = 0.1) |>
  st_sample(50)

plot(net_clean)
plot(points, col = "firebrick", pch = 20, add = TRUE)
```

One thing we may be interested in, are the distances between the points. For example, to do cluster analysis or to find nearest neighbors. Normally, we would compute a distance matrix as follows.

```{r}
eucdist = st_distance(points)
eucdist[1:5, 1:5]
```

But say we know that the points are generated by a process that is spatially constrained to the network, and the mismatch between point locations and network edges is just because of measurement inaccuracies and representational inaccuracies (roads as centerlines instead of polygons). In that case we are interested in the network distances instead of the euclidean distances. This is where `sfnetworks` comes in.

```{r}
netdist = st_network_cost(net_clean, from = points, to = points)
netdist[1:5, 1:5]
```

In the example above, the points are snapped to their nearest network node before computing network distances. We can get more accurate distances when first blending the points into the network, such that their nearest node is guaranteed to be the nearest location on the nearest edge.

```{r}
net_blend = st_network_blend(net_clean, points)

plot(net_blend)
plot(points, col = "firebrick", pch = 20, add = TRUE)
```

```{r}
netdist = st_network_cost(net_blend, from = points, to = points)
netdist[1:5, 1:5]
```

```{r}
sum(eucdist)
sum(netdist)
```

Do note the sampling above was just to give an example of messy real-world data. We could of course also have sampled points on the edge geometries themselves.

```{r}
points = net_clean |>
  activate(edges) |>
  st_geometry() |>
  st_sample(50)

plot(net_clean)
plot(points, col = "firebrick", pch = 20, add = TRUE)
```

## Integration with linnet

When it comes to statistical point pattern analysis on spatial linear networks, `sfnetworks` will soon reach its limits. This is because the package is designed as a general-purpose geospatial network analysis package, without a dedicated application. However, we do offer integration with the `spatstat.linnet` package, which *is* specifically designed for statistical point pattern analysis on spatial linear networks. You can use `sfnetworks` to retrieve and pre-process the OpenStreetMap data, and then move to `spatstat.linnet` for the statistical analysis of point patterns on the retreived network. This is how we always intended `sfnetworks` to be, a basic building block for more domain-specific packages. See it in the same way as that for geostatistics there is the `gstat` package, and those functionalities are not included in `sf` or `stars`. They do, however, all integrate well with each other.

We can convert out sfnetwork object easily to a linnet object.

:::{.callout-note}
The `spatstat.linnet` package requires the spatial linear network to be simple, and will assume all edges are straight lines.
:::
  
```{r}
#| warning: false
library(spatstat.linnet)
```

```{r}
net_simple = convert(net_clean, to_spatial_simple)
net_linnet = as.linnet(net_simple)
```

```{r}
plot(net_linnet)
```

Conversion the other way around also works. Do note that linnet converted all edges into straight lines, because it cannot handle curved shapes of edge geometries.

```{r}
net_from_linnet = as_sfnetwork(net_linnet)
plot(net_from_linnet)
```

The points we sampled can be converted to represent a point pattern on the linear network.

```{r}
pp = lpp(points, net_linnet)

plot(pp)
```

This allows us for example to test for complete spatial randomness (CSR) of the point pattern.

```{r}
cdf.test(pp, "x")
```

We can also fit Poisson point process models to the point pattern ...

```{r}
m = lppm(pp)
m
```

... and us those to make predictions for all (or a given set of) locations on the network.

```{r}
predict(m) |>
  plot()
```
Predictive models can also include edge attributes as covariates.

```{r}
net_lintess = lintess(
  L = net_linnet, 
  df = data.frame(
    seg = seq_len(with_graph(net_simple, graph_size())), 
    t0 = 0, 
    t1 = 1, 
    tile = net_simple |> activate(edges) |> mutate(type = replace_na(type, "unknown")) |> pull(type)
  )
)

plot(net_lintess)
```
```{r}
m = lppm(pp ~ net_lintess)
m
```

This was a very fast and very abstract walk through the `sfnetworks` - `spatstat.linnet` integration. You are much more experts in this field than I am and will for sure know of nice application cases. The integration is there, but can still be improved! Want to be part of that? See [this issue](https://github.com/luukvdmeer/sfnetworks/issues/249).

## Visualizing networks with ggraph

::: callout-warning
For this functionality you will need to install `ggplot2` and `ggraph` from GitHub.
:::
  
```{r}
ggraph(net_clean, "sf") +
  geom_edge_sf(aes(color = surface)) +
  geom_node_sf(
    aes(color = centrality_betweenness()), 
    size = 0.5
  ) + theme_void()
```

```{r}
net_clean |> 
  activate(edges) |> 
  filter(surface == "asphalt") |> 
  activate(nodes) |> 
  filter(!node_is_isolated()) |> 
  ggraph("sf") +
  geom_edge_arc(aes(color = type)) +
  geom_node_sf(size = 0.2, color = "grey") +
  theme_void()
```
